# 基于分块汉明码与多项式码的McEliece公钥加密系统变式研究

## 组员名单与学号
- 组员1：孙瑞阳（学号：2023103465）
- 组员2：钱雷阳（学号：2023103466）
- 组员3：吴佳林（学号：2003103467）


## 摘要

McEliece公钥加密体制是一种基于编码理论的后量子密码方案，其安全性建立在随机线性码的通用译码问题之上。本研究设计并实现了两种McEliece变体：基于分块汉明码的McEliece系统和基于分块BCH码的McEliece系统，并从效率、安全性与实现复杂度三个维度进行了系统化对比分析。实验结果表明，汉明码变体在密钥生成、加密和解密速度方面具有显著优势，而BCH码变体则在密钥尺寸和密文扩张率上表现更优。两种方案均展现出良好的安全性，为后量子密码研究提供了有价值的参考。

## 引言

随着量子计算技术的快速发展，传统基于大整数分解和离散对数问题的公钥加密体制面临着被量子算法破解的风险。在这一背景下，后量子密码学研究受到了广泛关注，其中基于编码理论的McEliece公钥加密体制因其四十余年的安全性记录而成为重要候选方案。

McEliece方案采用纠错码的生成矩阵作为公钥基础，通过随机可逆矩阵和置换矩阵对原始码结构进行伪装。加密过程中，明文经过公钥编码后被主动添加特定数量的错误位，而解密端则依靠私钥保存的原始码参数实现纠错解码。该方案的安全性不依赖于大整数分解或离散对数问题，具备抵抗量子计算攻击的潜力。

本研究旨在探索以不同经典信道编码替代Goppa码的可行性，设计并实现基于分块汉明码和分块BCH码的McEliece变体，并从效率、安全性与实现复杂度三个维度进行对比分析，为McEliece方案的进一步优化提供理论基础和实践参考。

## 相关工作

### McEliece公钥加密体制

McEliece公钥加密体制由Robert McEliece于1978年提出，是最早的公钥加密体制之一。该方案基于代数编码理论，利用Goppa码的特性构建陷门函数。McEliece方案的主要优点包括：
- 加密速度快
- 安全性高，历经四十余年密码分析仍保持安全
- 抵抗量子计算攻击

其主要缺点是密钥尺寸较大，这也是后续研究着力改进的方向。

### 汉明码与BCH码

汉明码是一种线性分组码，能够检测并纠正单个错误。(15,11)汉明码的码长为15，信息位为11，校验位为4，最小汉明距离为3。汉明码的编码和解码算法简单高效，适合实时应用场景。

BCH码是一种循环码，能够检测并纠正多个错误。(15,7)BCH码的码长为15，信息位为7，校验位为8，最小汉明距离为5，能够纠正2个错误。BCH码的编码和解码算法相对复杂，但具有更强的纠错能力。

### McEliece方案基于的计算难题

McEliece方案的安全性建立在**随机线性码的通用译码问题**之上，该问题属于NP困难范畴。具体来说，给定一个随机生成的线性码的生成矩阵G和一个被添加了t个错误的码字y，找到原始码字c使得d(y,c) ≤ t的问题是NP困难的。

这一问题的困难性来自于两个方面：
1. 随机线性码没有已知的代数结构可以利用，攻击者无法采用高效的代数译码算法
2. 暴力破解需要尝试所有可能的错误模式，时间复杂度随错误数t呈指数增长

### S矩阵和P矩阵的作用

在McEliece方案中，S矩阵和P矩阵扮演着至关重要的角色，它们共同作用于原始生成矩阵G，生成公钥G' = S × G × P。具体作用如下：

#### S矩阵（随机可逆矩阵）
- **作用**：对原始生成矩阵的行进行线性变换，破坏矩阵的稀疏性和代数结构
- **性质**：k×k的随机可逆矩阵，在GF(2)上可逆
- **效果**：使得生成矩阵的行看起来是随机的，隐藏了原始码的结构

#### P矩阵（随机置换矩阵）
- **作用**：对生成矩阵的列进行随机置换，打乱码的位置结构
- **性质**：n×n的置换矩阵，每行每列只有一个1
- **效果**：使得生成矩阵的列看起来是随机排列的，进一步隐藏了原始码的结构

通过S矩阵和P矩阵的双重伪装，公钥G'看起来像一个随机线性码的生成矩阵，而私钥持有者则可以利用原始码的结构进行高效解码。

## 方案设计与实现

### 系统总体架构

本研究实现的两种McEliece变体均采用分块结构，通过级联多个基础编码块来构建总体码。系统主要包括四个模块：
1. **编码模块**：实现基础编码算法，包括汉明码和BCH码的编码和解码
2. **密钥生成模块**：生成公钥和私钥，包括S矩阵、P矩阵的生成和公钥计算
3. **加密模块**：将明文加密为密文，包括矩阵乘法和错误添加
4. **解密模块**：将密文解密为明文，包括逆置换、解码和逆线性变换

### 基于分块汉明码的McEliece系统

#### 编码设计

采用(15,11)汉明码作为基础编码块，通过级联L个块构建总体码。每个汉明码块能够纠正1个错误，因此总体码能够纠正L个错误。例如：
- L=5时，总体码为(75,55)，能够纠正5个错误
- L=10时，总体码为(150,110)，能够纠正10个错误
- L=20时，总体码为(300,220)，能够纠正20个错误

汉明码的生成矩阵G为11×15矩阵，分块汉明码的生成矩阵为对角块矩阵，每个块为一个(15,11)汉明码的生成矩阵。这种分块结构使得编码和解码可以并行处理，提高了系统的效率。

#### 密钥生成

1. **初始化汉明码实例**：创建(15,11)汉明码对象，获取其生成矩阵G_hamming
2. **构建分块生成矩阵**：创建L×L的对角块矩阵G_total，每个对角块为G_hamming
3. **生成S矩阵**：生成k_total×k_total的随机可逆矩阵S，其中k_total=11×L
4. **生成P矩阵**：生成n_total×n_total的随机置换矩阵P，其中n_total=15×L
5. **计算公钥**：G_pub = S @ G_total @ P
6. **生成私钥**：私钥包含S矩阵、P矩阵、分块生成矩阵G_total和汉明码实例

#### 加密过程

1. 将明文m分割为L个长度为11的块m₁, m₂, ..., m_L
2. 计算密文c' = m × G' + e，其中e是随机错误向量，每个编码块最多包含1个错误
3. 输出密文c = c'

#### 解密过程

1. **逆置换**：计算c' = c @ P⁻¹，恢复到原始列顺序
2. **分块解码**：将c'分割为L个汉明码块，每个块使用汉明码解码器进行解码，纠正1个错误
3. **拼接解码结果**：将L个解码后的块拼接为向量m'
4. **逆线性变换**：计算m = m' @ S⁻¹，恢复原始明文

### 基于分块BCH码的McEliece系统

#### 编码设计

采用(15,7)BCH码作为基础编码块，通过级联L个块构建总体码。每个BCH码块能够纠正2个错误，因此总体码能够纠正2L个错误。例如：
- L=5时，总体码为(75,35)，能够纠正10个错误
- L=10时，总体码为(150,70)，能够纠正20个错误
- L=20时，总体码为(300,140)，能够纠正40个错误

BCH码的生成多项式为g(x) = x⁸ + x⁷ + x⁶ + x⁴ + 1，其生成矩阵G为7×15矩阵。分块BCH码的生成矩阵同样为对角块矩阵，每个块为一个(15,7)BCH码的生成矩阵。

#### 密钥生成

1. **初始化BCH码实例**：创建(15,7)BCH码对象，获取其生成矩阵G_bch
2. **构建分块生成矩阵**：创建L×L的对角块矩阵G_total，每个对角块为G_bch
3. **生成S矩阵**：生成k_total×k_total的随机可逆矩阵S，其中k_total=7×L
4. **生成P矩阵**：生成n_total×n_total的随机置换矩阵P，其中n_total=15×L
5. **计算公钥**：G_pub = S @ G_total @ P
6. **生成私钥**：私钥包含S矩阵、P矩阵、分块生成矩阵G_total和BCH码实例

#### 加密过程

1. **消息预处理**：将明文消息转换为GF(2)上的向量m
2. **公钥编码**：计算c1 = m @ G_pub
3. **错误添加**：生成随机错误向量e，每个BCH码块添加2个错误，共2L个错误
4. **生成密文**：c = c1 + e

#### 解密过程

1. **逆置换**：计算c' = c @ P⁻¹，恢复到原始列顺序
2. **分块解码**：将c'分割为L个BCH码块，每个块使用BCH码解码器进行解码，纠正2个错误
3. **拼接解码结果**：将L个解码后的块拼接为向量m'
4. **逆线性变换**：计算m = m' @ S⁻¹，恢复原始明文

### 实现细节

#### 汉明码实现

汉明码的实现采用了标准的(15,11)汉明码结构，其中：
- 校验位位于位置1、2、4、8（1-indexed）
- 数据位位于剩余位置
- 生成矩阵G为系统形式[I_k | P]，其中I_k是11×11单位矩阵，P是11×4校验矩阵
- 解码采用 syndrome decoding 算法，通过计算 syndrome 确定错误位置

#### BCH码实现

BCH码的实现基于galois库，其中：
- 生成多项式g(x) = x⁸ + x⁷ + x⁶ + x⁴ + 1
- 码长n=15，信息位k=7，校验位r=8
- 能够纠正t=2个错误
- 解码采用标准的BCH解码算法

#### S矩阵和P矩阵的生成

##### S矩阵生成
S矩阵的生成采用了随机生成和可逆性检验的方法：
1. 随机生成k_total×k_total的GF(2)矩阵
2. 检查矩阵是否可逆（通过计算行列式或尝试求逆）
3. 如果不可逆，重新生成，直到找到可逆矩阵

##### P矩阵生成
P矩阵的生成采用了随机置换的方法：
1. 生成1到n_total的随机置换
2. 基于该置换生成置换矩阵

## 实验设计

### 实验环境

- 操作系统：Windows 11
- CPU：Intel® Core™ i7-11700F
- 内存：16 GB
- 开发语言：Python 3.12
- 依赖库：numpy, galois

### 实验参数

- 汉明码变体：L=5, 10, 20
- BCH码变体：L=5, 10, 20
- 每种参数组合重复测试10次，取平均值

### 测量指标

1. 密钥生成时间
2. 加密时间
3. 解密时间
4. 密文扩张率（密文长度/明文长度）
5. 公钥尺寸

## 实验结果与分析

### 演示程序运行结果

#### 汉明码变体演示结果

```
============================================================
Hamming-based McEliece Cryptosystem Demo
============================================================

Parameters:
  Number of blocks (L): 5
  Hamming code: (15, 11)
  Message length: 55 bits
  Ciphertext length: 75 bits

[1] Generating keys...
  Public key size: (55, 75)
  Error correction capability: 5 errors (1 per block)
  Key generation complete!

[2] Original message (55 bits):
  [1 1 1 0 1 1 1 1 0 1 1 0 1 0 1 0 0 0 1 0]... (showing first 20 bits)

[3] Encrypting message...
  Ciphertext (75 bits):
  [0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0 0]... (showing first 20 bits)
  Encryption complete!

[4] Decrypting ciphertext...
  Decrypted message (55 bits):
  [1 1 1 0 1 1 1 1 0 1 1 0 1 0 1 0 0 0 1 0]... (showing first 20 bits)

[5] Verification:
  ✓ SUCCESS: Decrypted message matches original!
============================================================
```

#### BCH码变体演示结果

```
============================================================
BCH-based McEliece Cryptosystem Demo
============================================================

Parameters:
  Number of blocks (L): 5
  BCH code: (15, 7)
  Message length: 35 bits
  Ciphertext length: 75 bits

[1] Generating keys...
  Public key size: (35, 75)
  Error correction capability: 10 errors (2 per block)
  Key generation complete!

[2] Original message (35 bits):
  [1 0 1 1 0 1 1 0 0 0 0 1 0 0 0 0 1 0 1 1]... (showing first 20 bits)

[3] Encrypting message...
  Ciphertext (75 bits):
  [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 0]... (showing first 20 bits)
  Encryption complete!

[4] Decrypting ciphertext...
  Decrypted message (35 bits):
  [1 0 1 1 0 1 1 0 0 0 0 1 0 0 0 0 1 0 1 1]... (showing first 20 bits)

[5] Verification:
  ✓ SUCCESS: Decrypted message matches original!
============================================================
```

演示结果表明，两种McEliece变体均能正确完成密钥生成、加密和解密过程，解密后的消息与原始消息完全匹配，验证了系统的正确性。

### 基准测试结果

#### 汉明码变体

| L值 | 密钥生成时间(s) | 加密时间(s) | 解密时间(s) | 密文扩张率 | 公钥尺寸(KB) |
|-----|---------------|------------|------------|-----------|--------------|
| 5   | 0.194385      | 0.000000   | 0.008933   | 1.36      | 0.50         |
| 10  | 0.020931      | 0.000333   | 0.016448   | 1.36      | 2.01         |
| 20  | 0.054798      | 0.000167   | 0.039388   | 1.36      | 8.06         |

#### BCH码变体

| L值 | 密钥生成时间(s) | 加密时间(s) | 解密时间(s) | 密文扩张率 | 公钥尺寸(KB) |
|-----|---------------|------------|------------|-----------|--------------|
| 5   | 0.910013      | 0.000000   | 0.764501   | 2.14      | 0.32         |
| 10  | 0.045581      | 0.000670   | 0.021123   | 2.14      | 1.28         |
| 20  | 0.059641      | 0.000561   | 0.038060   | 2.14      | 5.13         |

### 性能分析

#### 1. 密钥生成时间

汉明码变体的密钥生成时间总体上明显小于BCH码变体：
- 在L=5时，汉明码变体的密钥生成时间仅为BCH码变体的21.47%（0.194385s vs 0.910013s）
- 随着L值的增加，两种变体的密钥生成时间差异逐渐减小
- 这主要是因为BCH码的生成矩阵计算更为复杂，需要进行多项式运算

#### 2. 加密时间

两种变体的加密时间都非常短，基本都在微秒级别：
- 汉明码变体的加密时间略小于BCH码变体
- 在L=20时，汉明码变体的加密时间仅为BCH码变体的29.77%（0.000167s vs 0.000561s）
- 加密时间的差异主要与生成矩阵的大小和结构有关

#### 3. 解密时间

汉明码变体的解密时间总体上明显小于BCH码变体：
- 在L=5时，汉明码变体的解密时间仅为BCH码变体的1.17%（0.008933s vs 0.764501s）
- 随着L值的增加，两种变体的解密时间差异逐渐减小，在L=20时，两者的解密时间基本相当（0.039388s vs 0.038060s）
- 这主要是因为BCH码的解码算法比汉明码复杂得多，需要进行多项式运算和错误定位

#### 4. 密文扩张率

汉明码变体的密文扩张率（1.36）明显小于BCH码变体（2.14）：
- 密文扩张率是密文长度与明文长度的比值，该值越小，传输效率越高
- 这是因为汉明码的码率（k/n=11/15≈0.733）高于BCH码的码率（k/n=7/15≈0.467）

#### 5. 公钥尺寸

BCH码变体的公钥尺寸明显小于汉明码变体：
- 在L=20时，BCH码变体的公钥尺寸仅为汉明码变体的63.65%（5.13KB vs 8.06KB）
- 这是因为BCH码的生成矩阵行数（信息位k=7）少于汉明码的生成矩阵行数（信息位k=11），因此公钥矩阵的大小（k_total×n_total）更小
- 公钥尺寸是McEliece方案的一个重要性能指标，较小的公钥尺寸有利于存储和传输

### 安全性分析

#### 汉明码变体

汉明码变体的安全性主要取决于以下因素：
- **分块数量L**：L越大，系统能够纠正的错误数越多，安全性越高
- **每个块的错误数**：汉明码变体每个块添加1个错误，与汉明码的纠错能力匹配
- **S矩阵和P矩阵的随机性**：S矩阵和P矩阵的随机性越强，公钥的伪装效果越好

对于汉明码变体，攻击者面临的主要问题是随机线性码的通用译码问题，该问题属于NP困难范畴。随着L的增加，攻击者需要处理的码长和错误数也增加，安全性随之提高。

#### BCH码变体

BCH码变体的安全性主要取决于以下因素：
- **分块数量L**：L越大，系统能够纠正的错误数越多，安全性越高
- **每个块的错误数**：BCH码变体每个块添加2个错误，与BCH码的纠错能力匹配
- **S矩阵和P矩阵的随机性**：S矩阵和P矩阵的随机性越强，公钥的伪装效果越好

与汉明码变体类似，BCH码变体的安全性也建立在随机线性码的通用译码问题之上。由于BCH码变体每个块添加2个错误，因此在相同L值下，BCH码变体添加的总错误数是汉明码变体的2倍，安全性更高。

#### 安全性估算

根据信息论，密码系统的安全性可以用密钥熵来衡量。对于本研究实现的McEliece变体，密钥熵主要由以下部分组成：
1. **生成矩阵的熵**：由于生成矩阵是固定的（汉明码或BCH码），这部分熵为0
2. **S矩阵的熵**：k_total×k_total的GF(2)可逆矩阵的数量约为2^(k_total²)/k_total!
3. **P矩阵的熵**：n_total×n_total的置换矩阵的数量为n_total!

通过计算，汉明码变体和BCH码变体的密钥熵均大于1000比特，具备较高的安全性。具体估算如下：
- 对于L=20的汉明码变体，k_total=220，n_total=300，密钥熵约为220² + log2(300!) ≈ 48400 + 2035 ≈ 50435比特
- 对于L=20的BCH码变体，k_total=140，n_total=300，密钥熵约为140² + log2(300!) ≈ 19600 + 2035 ≈ 21635比特

## 讨论与结论

### 性能对比总结

| 性能指标 | 汉明码变体 | BCH码变体 | 优势方案 |
|---------|-----------|----------|---------|
| 密钥生成时间 | 快 | 慢 | 汉明码变体 |
| 加密时间 | 快 | 快 | 汉明码变体 |
| 解密时间 | 快 | 慢 | 汉明码变体 |
| 密文扩张率 | 低 | 高 | 汉明码变体 |
| 公钥尺寸 | 大 | 小 | BCH码变体 |
| 纠错能力 | L | 2L | BCH码变体 |

### 结论

本研究设计并实现了基于分块汉明码和分块BCH码的McEliece公钥加密系统，并从效率、安全性与实现复杂度三个维度进行了对比分析。通过详细分析S、P矩阵的作用机制，以及两种变体的设计原理和基于的计算难题，本研究揭示了不同编码方案对McEliece系统性能的影响。实验结果表明：

1. **汉明码变体**在密钥生成、加密和解密速度方面具有显著优势，密文扩张率也较低，适合对速度要求较高的应用场景。

2. **BCH码变体**的公钥尺寸较小，纠错能力更强，适合对密钥尺寸和安全性要求较高的应用场景。

3. 两种方案均展现出良好的安全性，密钥熵均大于1000比特，具备抵抗量子计算攻击的潜力。

4. **S矩阵和P矩阵**在McEliece系统中扮演着至关重要的角色，它们共同作用于原始生成矩阵，将其伪装成随机线性码的生成矩阵，从而保证了系统的安全性。

5. **随机线性码的通用译码问题**是McEliece系统的安全性基础，该问题的NP困难性确保了系统的安全性，使其能够抵抗量子计算攻击。

本研究为McEliece方案的进一步优化提供了理论基础和实践参考，未来可以考虑结合两种方案的优点，设计更高效、更安全的McEliece变体。例如，可以考虑使用更高码率的BCH码，或者结合不同编码方案的优点，设计混合编码方案。

## 致谢

感谢《信息论与编码理论基础》课程老师的指导和帮助，感谢组员们的共同努力。

## 参考文献

1. McEliece, R. J. (1978). A public-key cryptosystem based on algebraic coding theory. DSN Progress Report, 42(44), 114-116.
2. Hamming, R. W. (1950). Error detecting and error correcting codes. Bell System Technical Journal, 29(2), 147-160.
3. Bose, R. C., Chaudhuri, D. K., & Hocquenghem, A. (1960). On a class of error correcting binary group codes. Information and Control, 3(1), 68-79.
4. Post-Quantum Cryptography Standardization, NISTIR 8105, 2016.
5. Berlekamp, E. R., McEliece, R. J., & van Tilborg, H. C. (1978). On the inherent intractability of certain coding problems. IEEE Transactions on Information Theory, 24(3), 384-386.

## 附录

### 代码结构

```
code/
  __init__.py
  utils.py                    # 共享工具函数
  hamming_mceliece/
    __init__.py
    hamming_code.py          # 汉明码实现
    keygen.py                # 密钥生成
    encrypt.py               # 加密
    decrypt.py               # 解密
  bch_mceliece/
    __init__.py
    bch_code.py             # BCH码实现
    keygen.py               # 密钥生成
    encrypt.py              # 加密
    decrypt.py              # 解密
run_hamming_demo.py         # 汉明码变体演示脚本
run_bch_demo.py             # BCH码变体演示脚本
run_benchmark.py            # 基准测试脚本
requirements.txt            # 依赖库
```

### 运行说明

#### 安装依赖

```bash
pip install -r requirements.txt
```

#### 运行演示

```bash
# 运行汉明码变体演示
python run_hamming_demo.py

# 运行BCH码变体演示
python run_bch_demo.py
```

#### 运行基准测试

```bash
python run_benchmark.py
```

### 关键参数说明

| 参数 | 汉明码变体 | BCH码变体 |
|-----|-----------|----------|
| 基础码型 | (15,11)汉明码 | (15,7)BCH码 |
| 每个块错误数 | 1 | 2 |
| 生成多项式 | - | g(x)=x⁸ + x⁷ + x⁶ + x⁴ + 1 |
| 分块数量L | 5, 10, 20 | 5, 10, 20 |